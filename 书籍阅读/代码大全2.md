#### 5 软件构建中的设计
- 启发式方法
  - 使用设计模式
  - 语义上的耦合是非常危险的。讲解了一些实例。102页。
  - 使用枚举值，代替 布尔值变量。
  - 设计类，隐藏些什么？如果能在给类的公开接口中增加函数或者数据而不牺牲该类的隐秘性。那么就做下去。
  - 找出容易改变的区域，不稳定的区域，隔离出来.
  - 尽可能缩减相互链接。
- 5.4 设计实践
  - 分而治之，自上而下和自下而上的设计方法。（自下而上，就像在自己组装玩具：我想自己组装完了，可为什么盒子里还有零件呢？^_^）
  - 设计中充满了反复的实验，请尝试些设计方案。直到找到最佳的一种。

#### 6 可以工作的类
- 抽象子程序注意，把类的公用子程序看做是潜水艇上用来防止进水的气锁阀，那么类中不一致的公用子程序就相当于漏水的仪表盘。但是有足够的时间，它还是能让潜水艇沉没的。
- 不要暴露成员数据，
- 阅读代码的次数要比编写代码多得多。即使开发初期也是。
- 继承（“是一个......” 关系）
  - 使用 public 继承实现 “是一个.....” 的关系。
  - 要么使用继承并进行详细说明，要么不要用它。
  - 遵循 Liskov 替换原则
  - 确保只继承需要继承的部分。
  - 不要 “覆盖” 一个不可覆盖的成员函数。
  - 把共用的接口，数据及操作放到继承树中尽可能高的位置。
  - 只有一个实例的类是值得怀疑的。
  - 只有一个派生类的基类也是值得怀疑的。
  - 派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也是值得怀疑的。
  - 避免让继承体系过深。
  - 尽量使用多态，避免大量的类型检查。
- 用私用（private）构造函数来强制实现单件属性。
```
Java示例： 用私用构造函数来实现Singleton(单件)
public class MaxId {
    // constructors and destructors
    // 这里就是私用构造函数
    private MaxId() {
        ...
    }
    // public routines
    // 这里是提供对唯一实例进行访问的公用方法
    public static MaxId GetInstrance() {
        return m_instance;
    }
    ....
    // private members
    // 这是唯一实例
    private static final MaxId m_instance = new MaxId()
}
```