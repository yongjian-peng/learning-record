Ubuntu 开发板测试结果

```
1. 烧录安卓和Ubuntu 系统成功。
2. 验证功能 可用的
	HDMI 接入线可以显示。
	GMAC 千兆网卡一路正常使用，另外一路的话则有  MAC 地址没有玩网络
	USB 接口 2.0 和 3.0 都能正常读取到 U盘。
3. 验证没有生效的，由于镜像是固定的，不是我们自己编写源码编译的。暂时测试不生效，不代表功能有问题。
	EDP 显示则失败，硬件设计有电源开启逻辑，需要软件来控制。
	SATA 存储 PCIE 接口没有生效。
	GMAC 千兆网卡，有一路是上不了网的。
	SD 卡 验证读取不到
	
```





#### Ubuntu 原理图

```
串口中，跳线帽切换是怎样的逻辑。
使用了 千兆网卡 用了 PHY0 PHY1 剩下了 PHY2 后，确认下，（是不是SATA 和 4/5G 公用一个，只能一个生效）。
RS232 中 U43 在板子上，给拆掉了。但是原理图中 使用的是  UART0_M0、UART4_M1、UART9_M1
使用EDP时候，差分信号对，强绑定到了高速引脚上，封装在了 PHY 层，从芯片原理图到使用EDP 功能这个过程是怎么样的？

软件中，初始化 CH7511B 时候，关于寄存器的配置。根据技术手册来分析源码中的配置项的含义。
```



#### 蓝牙复位脚再次控制失败

```
wireless_bluetooth 蓝颜 引脚 BT_REG_ON， 刚上电时候，是可以控制的。再次重启蓝牙后，就不能开启了
&wireless_bluetooth {
	compatible = "bluetooth-platdata";
	clocks = <&rk809 1>;
	clock-names = "ext_clock";
	//wifi-bt-power-toggle;

	/* BT_REG_ON 蓝牙电源的开关 */
	// BT,power_gpio = <&gpio2 RK_PB7 GPIO_ACTIVE_HIGH>;

	uart_rts_gpios = <&gpio2 RK_PB5 GPIO_ACTIVE_LOW>;

	pinctrl-names = "default", "rts_gpio";
	pinctrl-0 = <&uart1m0_rtsn>;
	pinctrl-1 = <&uart1_gpios>;
	BT,reset_gpio    = <&gpio2 RK_PB7 GPIO_ACTIVE_HIGH>;
	//BT,wake_gpio     = <&gpio3 RK_PA2 GPIO_ACTIVE_HIGH>;
	//BT,wake_host_irq = <&gpio3 RK_PA1 GPIO_ACTIVE_HIGH>;

	BT,wake_gpio     = <&gpio2 RK_PC1 GPIO_ACTIVE_HIGH>;
	BT,wake_host_irq = <&gpio2 RK_PC0 GPIO_ACTIVE_HIGH>;
	status = "okay";
};
```

![image-20251024105822937](./问题记录.assets/image-20251024105822937.png)

然后检查引脚 &gpio2 RK_PB7 给空出来，单独手动控制，如果是高电平时候，就拉不低。如果是低电平时候，手动更改，就拉不高。

```
echo 79 > /sys/class/gpio/export

# 设置为输出模式
echo out > /sys/class/gpio/gpio79/direction

# 输出高电平
echo 1 > /sys/class/gpio/gpio79/value

cat /sys/class/gpio/gpio79/value
0
```

最后排查是，其他 gmac0 IO 口给占用了， 给关闭了就可以控制了 复位引脚了

```
&gmac0 {
	pinctrl-0 = <&gmac0_rx_bus2>;
	status = "disable";
};

gmac0_rx_bus2: gmac0-rx-bus2 {
        rockchip,pins =
            /* gmac0_rxd0 */
            <2 RK_PB6 1 &pcfg_pull_none>,
            /* gmac0_rxd1 */
            <2 RK_PB7 2 &pcfg_pull_none>,
            /* gmac0_rxdvcrs */
            <2 RK_PC0 2 &pcfg_pull_none>;
```





### 串口

- 怎么区分控制寄存器 CR1 异步 CR2 同步 CR3 DMA 
  - 是都需要配置的，根据场景去配置对应的寄存器。


### C语言
- C99 的语法，比 C89要松一些。


### 需求
自动检测部分功能：
①光敏电阻每100ms检测光照强度调节LED的亮度(光照强度越强，灯的亮度越亮)
②毒气检测每100ms 检测毒气浓度，超过20%浓度，
通风(电机)启动同时关闭阀门(舵机转180度)，毒气越浓电机越快，
③每100ms通过串口显示芯片内部温度值
④在毒气泄漏情况，50cm内不能有人靠近，如果低于50cm，蜂鸣器报警
操作部分功能：
KEY1 ---RGB彩灯  红色
KEY2 ---RGB彩灯  绿色
KEY3 ---RGB彩灯  蓝色
KEY4 ---RGB彩灯  随机变换颜色

PC端口发送字符串open,阀门打开
PC端口发送字符串close,阀门关闭


	TIM14_CH1   PA7    舵机      5.5V
	ADC1_CH10   PC0    毒气      5V
	ADC1_CH12   PC2    光敏      3.3V
	TIM13_CH1   PA6    直流电机   3.3V
	
	TIM4_CH1    PB06   超声波距离 5V
	Echo        PB6
	Trig        PB8
	
	R           PA1    TIM5_CH2
	G           PA2    TIM5_CH3
	B           PA3    TIM5_CH4
	
	ADC1_CH16     温度


什么是IIC通信
IIC通信是双向二线制通信，有数据线和时钟线，其特点是：同步，串行，半双工模式。
设备可以一主多从方式使用，每个从设备都有设备地址。主机发送给从设备作为唯一标识。
配置方式有控制器，和模拟信号方式，常用模拟信号方式。方便移植。
时序包括有（空闲段，起始段，数据发送端，应答段，停止段）。
时钟线为高电平时候，可以读数据，时钟线为低电平时候，可以写数据。发送一个数据，从大到小的方式发送。
需要实现的逻辑包含有（初始化IIC函数，起始位函数，发送一个字节函数，接收一个字节函数，应答验证函数，应答发送函数，和结束函数）


什么是串口通信
串口通信是异步，串行，全双工模式，有发送和接收两个数据线。没有时钟线。使用串口设备都有自己的时钟频率。
配置方式，有控制器配置和模拟信号的方式，常用控制器配置来实现。
时序包括有（起始段，数据发送和接收，数据校验位，停止段）。需要配置为相同频率的时钟，常用 115200.波特率。
控制器配置可以查询等待和中断实现。常用中断实现。
需要实现的方法有，初始化函数，发送一个字节函数，接收中断服务函数。


### 野火应用
- 显示图片历程：显示图片及屏幕截图 - 4.3寸
- 电容触摸屏-触摸画板：可以写字画板。

### 看芯片说明
- 看特点
- 看引脚
- 如何操作
  - 如何跟主控芯片数据交换

### 总结什么是 SPI 或者 IIC 的 总体思路
- 特点
- 配置方式
- 配置思路
- 使用案例 


怎么使用 AT24C02 ?
- 看手册
  - 看特点
  - 看引脚
  - 存储数据
- 设计程序
  - 初始化程序
  - 存储一个字节函数
  - 读取一个字节函数
  - 页存储函数
  - 连续读函数
  - 连续写可跨页写
- 使用他做了什么功能。
  - 存储了开始次数

### 遇到了一个奇怪的问题
- 在RTC 配置时间和日期的时候，起到了备份域的功能。
- RTC->TR &= ~(1 << 22) 放在下面的情况，形成了备份域的功能，放在上面则正常执行
```
  RTC->TR &= ~(1 << 22);									// 配置时间为24小时制
	RTC->TR = rtc_time;											// 设置RTC的时间
	RTC->DR = rtc_date;											// 设置RTC的日期
	printf("%X \r\n", rtc_time);
	
	//RTC->TR &= ~(1 << 22);									// 配置时间为24小时制
```
