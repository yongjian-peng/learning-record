1. **软件配置检查**：确认系统是否识别到声卡，驱动是否加载。
2. **基础功能测试**：使用系统命令进行录音和播放测试。
3. **外部设备检查**：确保耳机、扬声器、麦克风等硬件连接正确且完好。
4. **系统设置检查**：确认音量、默认设备等设置无误。



```
cat /proc/asound/cards
aplay -l
arecord -l

mpg123 ~

# 录制一段音频（5秒，单声道，16bit，8kHz）
arecord -d 5 -c 1 -f S16_LE -r 44100 /tmp/test_rec.wav
aplay /tmp/test_rec.wav

alsamixer

amixer -c 0 contents

/etc/init.d/S99volume-control status
/etc/init.d/S99volume-control start
cat /var/log/volume-keys.log

```



```
dmesg | grep -E "rk809|rk817|i2s|sound|audio|asoc"

amixer sget 'Master'

amixer controls

amixer sget 'Capture'

amixer cget numid=3

amixer sset 'Master' 80%

amixer sset 'Master' 90
amixer sset 'Master' 20000

amixer sget 'Master'

madplay -a +1 mnt/udisk/AUDIO/784\ MP3/02\ 1KHZ\,L\&R\,0DB.mp3 
madplay mnt/udisk/AUDIO/784\ MP3/02\ 1KHZ\,L\&R\,0DB.mp3 


gst-launch-1.0 playbin uri=file:///mnt/udisk/02\ 1KHZ\,L\&R\,0DB.mp3

# 先查看所有声卡列表，获取声卡编号（如 "1: USB Audio"）
aplay -l
# 查看编号为 1 的声卡的主音量
amixer -c 1 get Master









root@rk3568-buildroot:/# cat /usr/bin/volume-daemon.sh
#!/bin/sh
echo "Volume Key Daemon started (using Master control)"

# 设置初始音量为50%
amixer -q sset 'Master' 50%

while true; do
    # 使用evtest来监听事件，并过滤出按键按下事件
    /usr/bin/evtest /dev/input/event5 | while read -r line; do
        case "$line" in
            *"(KEY_VOLUMEUP), value 1")
                amixer -q sset 'Master' 5%+
                echo "VOLUME UP"
                ;;
            *"(KEY_VOLUMEDOWN), value 1")
                amixer -q sset 'Master' 5%-
                echo "VOLUME DOWN"
                ;;
            *"(KEY_MENU), value 1")
                echo "MENU KEY pressed"
                ;;
            *"(KEY_BACK), value 1")
                echo "BACK KEY pressed"
                ;;
        esac
    done
    sleep 1
done
root@rk3568-buildroot:/# 

```





```
root@rk3568-buildroot:/# cat usr/bin/volume-control.sh 
#!/bin/sh

# 智能设备识别函数
find_adc_keys_device() {
    local device_name="adc-keys"
    
    # 方法1: 检查 /sys/class/input 目录（最可靠）
    if [ -d "/sys/class/input" ]; then
        for event_dir in /sys/class/input/event*; do
            if [ -f "$event_dir/device/name" ]; then
                name=$(cat "$event_dir/device/name" 2>/dev/null)
                if [ "$name" = "$device_name" ]; then
                    event_num=$(basename "$event_dir" | sed 's/event//')
                    echo "/dev/input/event${event_num}"
                    return 0
                fi
            fi
        done
    fi
    
    # 方法2: 检查 /proc/bus/input/devices
    if [ -f "/proc/bus/input/devices" ]; then
        event_line=$(grep -A 4 "Name=\"$device_name\"" /proc/bus/input/devices | \
                    grep -o "event[0-9]*" | head -1)
        if [ -n "$event_line" ]; then
            echo "/dev/input/$event_line"
            return 0
        fi
    fi
    
    # 方法3: 使用 evtest 扫描所有设备
    for event_device in /dev/input/event*; do
        if [ -c "$event_device" ]; then
            # 使用 evtest --info 获取设备信息
            device_info=$(evtest --info "$event_device" 2>/dev/null)
            if echo "$device_info" | grep -q "$device_name"; then
                echo "$event_device"
                return 0
            fi
            
            # 尝试直接读取设备信息
            if which evtest >/dev/null 2>&1; then
                if evtest "$event_device" 2>&1 | head -5 | grep -q "$device_name"; then
                    echo "$event_device"
                    return 0
                fi
            fi
        fi
    done
    
    # 方法4: 最后尝试已知的事件编号（0-9）
    for i in 0 1 2 3 4 5 6 7 8 9; do
        if [ -c "/dev/input/event${i}" ]; then
            if evtest --info "/dev/input/event${i}" 2>/dev/null | grep -q "$device_name"; then
                echo "/dev/input/event${i}"
                return 0
            fi
        fi
    done
    
    return 1
}

# 获取设备路径函数
get_adc_keys_device() {
    local max_retries=10
    local retry_interval=2
    
    for attempt in $(seq 1 $max_retries); do
        device=$(find_adc_keys_device)
        if [ $? -eq 0 ] && [ -n "$device" ] && [ -c "$device" ]; then
            echo "$device"
            return 0
        fi
        
        if [ $attempt -lt $max_retries ]; then
            log_message "尝试 $attempt/$max_retries: 未找到 adc-keys 设备，等待重试..."
            sleep $retry_interval
        fi
    done
    
    log_message "错误: 经过 $max_retries 次尝试后仍未找到 adc-keys 设备"
    return 1
}

# 日志函数
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S'): $1" >> /var/log/volume-keys.log
    # 同时输出到控制台（便于调试）
    echo "$(date '+%H:%M:%S'): $1"
}

# 音量控制函数
control_volume() {
    local action=$1
    case $action in
        "up")
            if amixer set Master 5%+ >/dev/null 2>&1; then
                current_volume=$(amixer get Master | grep -oE '[0-9]+%' | head -1 2>/dev/null || echo "未知")
                log_message "音量增加 - 当前音量: $current_volume"
            else
                log_message "错误: amixer 命令执行失败"
            fi
            ;;
        "down")
            if amixer set Master 5%- >/dev/null 2>&1; then
                current_volume=$(amixer get Master | grep -oE '[0-9]+%' | head -1 2>/dev/null || echo "未知")
                log_message "音量减少 - 当前音量: $current_volume"
            else
                log_message "错误: amixer 命令执行失败"
            fi
            ;;
        "mute")
            if amixer set Master toggle >/dev/null 2>&1; then
                mute_state=$(amixer get Master | grep -oE '\[on\]|\[off\]' | head -1 2>/dev/null || echo "未知")
                log_message "静音切换 - 状态: $mute_state"
            else
                log_message "错误: amixer 静音命令执行失败"
            fi
            ;;
    esac
}

# 检查依赖工具
check_dependencies() {
    if ! which evtest >/dev/null 2>&1; then
        log_message "错误: evtest 工具未安装"
        return 1
    fi
    
    if ! which amixer >/dev/null 2>&1; then
        log_message "错误: amixer 工具未安装"
        return 1
    fi
    
    return 0
}

# 确保目录存在
setup_environment() {
    mkdir -p /var/log
    mkdir -p /var/run
}

# 主函数
main() {
    setup_environment
    
    if ! check_dependencies; then
        log_message "依赖检查失败，退出服务"
        exit 1
    fi
    
    log_message "启动音量按键监听服务"
    
    # 主循环
    while true; do
        # 获取设备路径
        DEVICE=$(get_adc_keys_device)
        if [ $? -ne 0 ]; then
            log_message "无法找到 adc-keys 设备，等待10秒后重试..."
            sleep 10
            continue
        fi
        
        log_message "找到设备: $DEVICE，开始监听..."
        
        # 监听设备事件
        evtest "$DEVICE" 2>/dev/null | while read -r line; do
            # 检测音量加按键按下
            if echo "$line" | grep -q "code 115 (KEY_VOLUMEUP).*value 1"; then
                control_volume "up"
            
            # 检测音量减按键按下
            elif echo "$line" | grep -q "code 114 (KEY_VOLUMEDOWN).*value 1"; then
                control_volume "down"
            
            # 检测菜单键（可选静音功能）
            elif echo "$line" | grep -q "code 139 (KEY_MENU).*value 1"; then
                control_volume "mute"
            
            # 调试信息：显示所有按键事件
            # elif echo "$line" | grep -q "EV_KEY"; then
            #     echo "调试: $line"
            fi
        done
        
        # 如果 evtest 退出，说明设备可能断开
        log_message "设备 $DEVICE 监听中断，5秒后重新尝试连接..."
        sleep 5
    done
}

# 运行主函数
main




root@rk3568-buildroot:/# cat etc/init.d/S99volume-control 
#!/bin/sh
# 音量控制服务的SysVinit启动脚本
# 放置路径：/etc/init.d/S99volume-control
# 启动命令：/etc/init.d/S99volume-control start
# 停止命令：/etc/init.d/S99volume-control stop
# 重启命令：/etc/init.d/S99volume-control restart

# 脚本路径（与放置的路径一致）
SCRIPT="/usr/bin/volume-control.sh"
# 进程PID文件（用于记录后台运行的进程ID，避免重复启动）
PID_FILE="/var/run/volume-control.pid"

# 检查并修复脚本权限
check_and_fix_permissions() {
    # 检查脚本是否存在
    if [ ! -f "$SCRIPT" ]; then
        echo "错误: 脚本 $SCRIPT 不存在!"
        return 1
    fi
    
    # 检查脚本是否有执行权限
    if [ ! -x "$SCRIPT" ]; then
        echo "警告: 脚本 $SCRIPT 缺少执行权限，正在修复..."
        # 添加执行权限
        chmod +x "$SCRIPT"
        
        # 验证权限是否添加成功
        if [ -x "$SCRIPT" ]; then
            echo "成功: 已为 $SCRIPT 添加执行权限"
            return 0
        else
            echo "错误: 无法为 $SCRIPT 添加执行权限"
            return 1
        fi
    fi
    
    return 0
}

# 启动函数
start() {
    echo "启动音量控制服务..."
    
    # 先检查并修复权限
    if ! check_and_fix_permissions; then
        echo "权限检查失败，无法启动服务"
        return 1
    fi
    
    # 检查脚本是否可执行（双重确认）
    if [ ! -x "$SCRIPT" ]; then
        echo "错误: $SCRIPT 仍然不可执行!"
        return 1
    fi
    
    # 用start-stop-daemon后台启动脚本，记录PID到PID_FILE
    start-stop-daemon -S -b -m -p "$PID_FILE" -x "$SCRIPT"
    if [ $? -eq 0 ]; then
        echo "音量控制服务启动成功"
    else
        echo "错误: 音量控制服务启动失败"
        return 1
    fi
}

# 停止函数
stop() {
    echo "停止音量控制服务..."
    # 检查PID文件是否存在，存在则杀死进程并删除PID文件
    if [ -f "$PID_FILE" ]; then
        start-stop-daemon -K -p "$PID_FILE"  # -K表示停止进程
        rm -f "$PID_FILE"
        echo "音量控制服务已停止"
    else
        echo "音量控制服务未在运行"
    fi
}

# 重启函数
restart() {
    stop
    sleep 2  # 等待进程完全停止
    start
}

# 状态检查函数
status() {
    if [ -f "$PID_FILE" ] && kill -0 $(cat "$PID_FILE") 2>/dev/null; then
        echo "音量控制服务正在运行 (PID: $(cat "$PID_FILE"))"
    else
        echo "音量控制服务未在运行"
        rm -f "$PID_FILE"  # 清理残留的PID文件
    fi
}

# 根据命令行参数执行对应函数
case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        restart
        ;;
    status)
        status
        ;;
    *)
        echo "用法: $0 {start|stop|restart|status}"
        exit 1
        ;;
esac

exit 0

```

